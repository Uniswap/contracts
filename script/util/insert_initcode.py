import os
import json
import re
import sys
import textwrap


def update_initcode(sol_file_path, updated_initcode):
    with open(sol_file_path, 'r') as sol_file:
        content = sol_file.read()

    initcode_pattern = r"""
        ^\s*  # Match any leading whitespace at the beginning of the line
        (///\s*@dev\s+autogenerated\s*-\s*run\s*(?:``|`./script/util/create_briefcase.sh`)\s*to\s*generate\s*current\s*initcode\s*\n)  # @dev comment line
        \s*(function\s+initcode\s*\(([^)]*)\)\s+internal\s+pure\s+returns\s*\(\s*bytes\s+memory\s*\)\s*\{\s*\n)  # function definition, with optional parameters
        (.*?)   # Match any content in the function body
        (\})    # Closing brace
    """

    updated_content = re.sub(
        initcode_pattern,
        updated_initcode,
        content,
        flags=re.DOTALL | re.VERBOSE | re.MULTILINE
    )

    with open(sol_file_path, 'w') as sol_file:
        sol_file.write(updated_content)

    print(f"Updated initcode in {sol_file_path}")


def generate_solidity_initcode(json_file_path):
    with open(json_file_path, 'r') as json_file:
        json_data = json.load(json_file)

    bytecode = json_data["bytecode"]["object"][2:]
    link_references = json_data["bytecode"]["linkReferences"]
    solidity_parts = []
    parameter_names = []
    current_pos = 0

    if not link_references:
        # No link references, use the bytecode directly in a single string return
        generated_code = f"""\
        
        /// @dev autogenerated - run `./script/util/create_briefcase.sh` to generate current initcode
        function initcode() internal pure returns (bytes memory) {{
            return hex'{bytecode}';
        }}"""
    else:
        # Process link references if they exist
        for file_path, links in link_references.items():
            for contract_name, locations in links.items():
                for location in locations:
                    start = location["start"] * 2  # Convert to hex position
                    length = location["length"] * 2  # Convert to hex length
                    placeholder = bytecode[start:start + length]

                    # Check if placeholder matches expected format __$...$__
                    if not re.match(r"^__\$[0-9a-f]{34}\$__$", placeholder):
                        raise ValueError(
                            f"Invalid placeholder format found: {placeholder}")

                    # Add the segment before the placeholder to the parts list
                    solidity_parts.append(
                        f"hex'{bytecode[current_pos:start]}'")
                    address_param = f"{contract_name}"
                    parameter_names.append(address_param)
                    # Add address parameter to the parts list
                    solidity_parts.append(address_param)
                    current_pos = start + length  # Move position after the placeholder

        # Add remaining part of bytecode after the last placeholder
        solidity_parts.append(f"hex'{bytecode[current_pos:]}'")

        # Prepare function parameters list
        parameters = ", ".join(
            [f"address {param}" for param in parameter_names])

        # Use abi.encodePacked to join all parts together
        concat_code = "abi.encodePacked(" + ", ".join(solidity_parts) + ")"

        generated_code = f"""\
        
        /// @dev autogenerated - run `./script/util/create_briefcase.sh` to generate current initcode
        function initcode({parameters}) internal pure returns (bytes memory) {{
            return {concat_code};
        }}"""

    # Ensure correct indentation for the generated code
    indented_code = textwrap.indent(textwrap.dedent(generated_code), "    ")
    return indented_code


def process_directory(src_directory, json_directory):
    for root, dirs, files in os.walk(src_directory):
        for file in files:
            if file.endswith('Deployer.sol'):
                class_name = file.replace('Deployer.sol', '')
                json_file_subdirectory = f'{class_name}.sol'
                json_file_name = f'{class_name}.json'
                json_file_path = os.path.join(
                    json_directory, json_file_subdirectory, json_file_name)

                if os.path.exists(json_file_path):
                    print(f"Processing {file} with {json_file_name}")
                    sol_file_path = os.path.join(root, file)
                    try:
                        updated_initcode = generate_solidity_initcode(
                            json_file_path)
                        update_initcode(sol_file_path, updated_initcode)
                    except:
                        print(
                            f"Error while processing initcode for {file}, skipping")
                else:
                    print(f"JSON file {json_file_name} not found for {file}")


if __name__ == "__main__":
    src_directory = sys.argv[1]
    json_directory = sys.argv[2]

    process_directory(src_directory, json_directory)
